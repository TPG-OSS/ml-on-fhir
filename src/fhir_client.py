import requests
from fhir_objects.patient import Patient
from fhir_objects.condition import Condition
from fhir_objects.observation import Observation
from fhir_objects.procedure import Procedure
from preprocessing import register_preprocessor
import time
import importlib.util
import numpy as np


from os.path import join
import logging
from typing import Callable


class FHIRClient():

    def __init__(self, service_base_url: str, logger: logging.Logger=None, preprocessor=None):
        """
        Helper class to perform requests to a FHIR server.

        Attributes:
            server_url (str): Base url to be used for all requests (e.g. https://r3.smarthealthit.org)
            logger (logging.Logger): Logger to be used
            preprocessor (module): Preprocessor module to be used
        """
        self.server_url = service_base_url
        self.session = requests.Session()
        self.logger = logger
        self.preprocessor = preprocessor
        self.observation_preprocessors = None

        # On initialization request the capability statement from the server
        self.get_capability_statement()

        # On success we tell the user
        if self.logger and self.logger.isEnabledFor(logging.INFO):
            logger.info(f"Capability statement of {service_base_url} was successfully received.")

    @property
    def observation_preprocessors(self):
        """List of observation preprocessors"""
        return self._observation_preprocessors

    @observation_preprocessors.setter
    def observation_preprocessors(self, preprocessor=None):
        self._observation_preprocessors = self._preprocessor.get_observation_preprocessors()

    @observation_preprocessors.deleter
    def observation_preprocessors(self):
        del self._observation_preprocessors

    @property
    def preprocessor(self):
        """Module to be used for preprocessing"""
        return self._preprocessor

    @preprocessor.setter
    def preprocessor(self, preprocessor=None):
        if not preprocessor:
            spec = importlib.util.spec_from_file_location(
                "preprocessing", "./preprocessing.py")
            module = importlib.util.module_from_spec(spec)
            spec.loader.exec_module(module)
            self._preprocessor = module
        else:
            self._preprocessor = preprocessor

    @preprocessor.deleter
    def preprocessor(self, preprocessor=None):
        del self._preprocessor

    def _check_status(self, status_code: int):
        """
        Checks whether returned status code is 200

        Returns:
            True if status_code is OK (200), False otherwise
        """
        return status_code == requests.codes.ok

    def _build_url(self, path: str, **query_params):
        """
        Builds an url based on the class's server_url and query parameters

        Args:
            path (str): FHIR resource to be queried (e.g. Patient or Observation)
            **query_params: Dict of query parameters to build the query string
        """
        base_url = join(self.server_url, path)
        if query_params:
            base_url += '?'

        for param in query_params.keys():
            param_value = query_params[param]
            if param_value: 
                base_url += '{}={}&'.format(param, param_value)
        return base_url

    def _get(self, path: str, session: requests.Session=None, **query_params):
        """
        Builds the query string and submits a GET request

        Args:
            path (str): FHIR resource to be queried (e.g. Patient or Observation)
            session (requests.Session): Session to be used for query
            **query_params: Dict of query parameters to build the query string

        Returns:
            The requests.Response
        """
        url = self._build_url(path, **query_params)
        if session:
            return session.get(url)
        else:
            return requests.get(url)
    
    def _get_patients_ids(self):
        """
        In order to efficiently load a control population for a case population,
        patient IDs in the db are used to quickly load them recursively.

        Args:
            result_json (dict): The json result from the initial query
            session (requests.Session): Session to be used for all requests

        Returns:
            A list of objects generated by the constructor. E.g. a list of Patient objects.
        """

        # Build a dummy callable to use the self._collect function:
        def PatientID(resource_dict, fhir_client=None):
            return resource_dict['id']
        PatientID.__name__ = 'Patient'

        # Load Patient ids
        r = self._get('Patient', session=self.session, **{'_summary': 'text'})
        patient_ids = self._collect(r.json(), self.session, PatientID)
        return patient_ids

    def _collect(self, result_json: dict, session: requests.Session, constructor: Callable):
        """
        A server might return a pageinated result due to its settings.
        This method collects all results recursively.

        Args:
            result_json (dict): The json result from the initial query
            session (requests.Session): Session to be used for all requests
            constructor (Callable): The constructor with which to construct the result list

        Returns:
            A list of objects generated by the constructor. E.g. a list of Patient objects.
        """
        result = []
        for link in result_json['link']:
            if link['relation'] == 'next':
                r = session.get(link['url'])
                if self._check_status(r.status_code):
                    result = self._collect(r.json(), session, constructor)
                else:
                    r.raise_for_status()
            else:
                continue
        if 'entry' in result_json.keys():
            result += [constructor(resource_dict=d['resource'], fhir_client=self) for d in result_json['entry'] if d[
                'resource']['resourceType'] == constructor.__name__]
        return result

    def get_control_patients(self, results: list, random_seed=42):
        """
        Returns the control group for a set of patients

        Args:
            results: list of Patient object

        Returns:
            results: augmented results list with additional case flag 
                     (case=False for controls)
        """
        # Start by retrieving all patients IDs
        if not hasattr(self, 'patients_ids'):
            self.patients_ids = self._get_patients_ids()
            logging.info("Loaded {} patients IDs.".format(len(self.patients_ids)))
        
        # Group patients IDs from case group
        case_ids = set([r.id for r in results])

        # Check the difference
        control_ids = set(self.patients_ids).difference(case_ids)

        # Randomly sample from control ids, TODO: place general seed somewhere
        np.random.seed(random_seed)
        control_ids = np.random.choice(list(control_ids), size=min(len(control_ids), 
                                        max(10, len(case_ids))),replace=False)
        controls = []
        for i in control_ids:
            result_json = self._get('Patient', session=self.session, **{'_id': i}).json()
            if 'entry' in result_json.keys():
                controls.append(Patient(resource_dict=result_json['entry'][0]['resource'], fhir_client=self))
                controls[-1].case=False
        cases = []
        for r in results:
            r.case = True
            cases.append(r)
        return cases + controls

    def get_capability_statement(self):
        """
        Returns:
            The capability statement of the FHIR server.
        """
        r = self._get('metadata', session=self.session)

        if self._check_status(r.status_code):
            return r.json()
        else:
            r.raise_for_status()

    def get_all_patients(self, max_count=1000):
        """
        Gets a all patients

        Returns:
            List of fhir_objects.Patient.patient
        """
        if self.logger and self.logger.isEnabledFor(logging.INFO):
            start = time.time()

        r = self._get('Patient', session=self.session)

        if self._check_status(r.status_code):
            result = r.json()
            results = self._collect(result, self.session, Patient)

            if self.logger and self.logger.isEnabledFor(logging.INFO):
                end = time.time()
                logging.info("Received {} patients in {:.2f} seconds.".format(
                    len(results), end - start))

            return results
        else:
            r.raise_for_status()

    def get_all_conditions(self):
        """
        Gets all conditions

        Returns:
            List of fhir_objects.Condition.condition
        """
        if self.logger and self.logger.isEnabledFor(logging.INFO):
            start = time.time()

        r = self._get('Condition', session=self.session)

        if self._check_status(r.status_code):
            result = r.json()
            results = self._collect(result, self.session, Condition)

            if self.logger and self.logger.isEnabledFor(logging.INFO):
                end = time.time()
                logging.info("Received {} conditions in {:.2f} seconds.".format(
                    len(results), end - start))

            return results
        else:
            r.raise_for_status()

    def get_all_observations(self):
        """
        Gets all conditions

        Returns:
            List of fhir_objects.Condition.condition
        """
        if self.logger and self.logger.isEnabledFor(logging.INFO):
            start = time.time()

        r = self._get('Observation', session=self.session)

        if self._check_status(r.status_code):
            result = r.json()
            results = self._collect(result, self.session, Observation)

            if self.logger and self.logger.isEnabledFor(logging.INFO):
                end = time.time()
                logging.info("Received {} observations in {:.2f} seconds.".format(
                    len(results), end - start))

            return results
        else:
            r.raise_for_status()

    def get_all_procedures(self):
        """
        Gets all conditions

        Returns:
            List of fhir_objects.Condition.condition
        """
        if self.logger and self.logger.isEnabledFor(logging.INFO):
            start = time.time()

        r = self._get('Procedure', session=self.session)

        if self._check_status(r.status_code):
            result = r.json()
            results = self._collect(r.json(), self.session, Procedure)

            if self.logger and self.logger.isEnabledFor(logging.INFO):
                end = time.time()
                logging.info("Received {} procedures in {:.2f} seconds.".format(
                    len(results), end - start))

            return results
        else:
            r.raise_for_status()

    def get_patients_by_procedure_code(self, system: str, code: str, controls=False):
        """
        Gets all patients with procedure of a certain system code

        Args:
            system (str): System from which the code originates (e.g. 'http://snomed.info/sct')
            code (str): Code (e.g. 73761001)

        Returns:
            List of fhir_objects.Patient.patient
        """
        if self.logger and self.logger.isEnabledFor(logging.INFO):
            start = time.time()

        r = self._get('Patient', session=self.session, **
                      {'_has:Procedure:patient:code': '{}|{}'.format(system, code)})

        if self._check_status(r.status_code):
            result = r.json()
            results = self._collect(result, self.session, Patient)

            if self.logger and self.logger.isEnabledFor(logging.INFO):
                end = time.time()
                logging.info("Received {} patients in {:.2f} seconds.".format(
                    len(results), end - start))
            # If controls are to be returned, load them
            if controls:
                results = self.get_control_patients(results)

            return results
        else:
            r.raise_for_status()

    def get_patients_by_procedure_text(self, text: str, controls=False):
        """
        Gets all patients with procedure of a certain text (e.g. Colonoscopy)

        Args:
            text (str): Text of CodeableConcept.text, Coding.display, or Identifier.type.text.

        Returns:
            List of fhir_objects.Patient.patient
        """
        if self.logger and self.logger.isEnabledFor(logging.INFO):
            start = time.time()

        r = self._get('Procedure', session=self.session, **
                      {'code:text': text, '_include': 'Procedure:patient'})

        if self._check_status(r.status_code):
            result = r.json()
            results = self._collect(result, self.session, Patient)

            if self.logger and self.logger.isEnabledFor(logging.INFO):
                end = time.time()
                logging.info("Received {} patients in {:.2f} seconds.".format(
                    len(results), end - start))
            # If controls are to be returned, load them
            if controls:
                results = self.get_control_patients(results)

            return results
        else:
            r.raise_for_status()

    def get_patients_by_condition_code(self, system: str, code: str, controls=False):
        """
        Gets all patients with condition of a certain system code

        Args:
            system (str): System from which the code originates (e.g. 'http://snomed.info/sct')
            code (str): Code (e.g. 195662009)

        Returns:
            List of fhir_objects.Patient.patient
        """
        if self.logger and self.logger.isEnabledFor(logging.INFO):
            start = time.time()

        r = self._get('Patient', session=self.session, **
                      {'_has:Condition:patient:code': '{}|{}'.format(system, code)})

        if self._check_status(r.status_code):
            result = r.json()
            results = self._collect(result, self.session, Patient)

            if self.logger and self.logger.isEnabledFor(logging.INFO):
                end = time.time()
                logging.info("Received {} patients in {:.2f} seconds.".format(
                    len(results), end - start))
            # If controls are to be returned, load them
            if controls:
                results = self.get_control_patients(results)


            return results
        else:
            r.raise_for_status()

    def get_patients_by_condition_text(self, text: str, controls=False):
        """
        Gets all patients with condition of a certain text (e.g 'Acute viral pharyngitis')

        Args:
            text (str): Text of CodeableConcept.text, Coding.display, or Identifier.type.text.

        Returns:
            List of fhir_objects.Patient.patient
        """
        if self.logger and self.logger.isEnabledFor(logging.INFO):
            start = time.time()

        r = self._get('Condition', session=self.session, **
                      {'code:text': text, '_include': 'Condition:patient'})

        if self._check_status(r.status_code):
            result = r.json()
            results = self._collect(result, self.session, Patient)

            if self.logger and self.logger.isEnabledFor(logging.INFO):
                end = time.time()
                logging.info("Received {} patients in {:.2f} seconds.".format(
                    len(results), end - start))
            # If controls are to be returned, load them
            if controls:
                results = self.get_control_patients(results)

            return results
        else:
            r.raise_for_status()

    def get_observation_by_patient(self, patient_id: str):
        """
        Gets all observations for a given patient that is of status final, unknown, amended, corrected.

        Args:
            patient_id (str): The patient resource identifier
        """
        if self.logger and self.logger.isEnabledFor(logging.INFO):
            start = time.time()

        r = self._get('Observation', session=self.session,
                      status='final,unknown,amended,corrected', patient=patient_id)
        if self._check_status(r.status_code):
            result = r.json()
            results = self._collect(result, self.session, Observation)

            if self.logger and self.logger.isEnabledFor(logging.INFO):
                end = time.time()
                logging.info("Received {} observations in {:.2f} seconds.".format(
                    len(results), end - start))

            return results
        else:
            r.raise_for_status()
